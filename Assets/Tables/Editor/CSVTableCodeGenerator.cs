using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace Elysia.Tables
{
    public static class CSVTableCodeGenerator
    {
        private static readonly string scriptTemplate =
@"// <auto-generated>
//  automatically generated by CSVTableCodeGenerator, do not modify
// </auto-generated>

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Elysia.Tables
{
    public class %%CLASS_NAME%%
    {
        public class Row
        {
[[VARIABLE]]

            public Row(string[] source)
            {
[[VARIABLE_INITIALIZER]]
            }
        }

[[MEMBER_VARIABLE]]

        public int Count => rows.Count;

        public void Load()
        {
            Regex regex = new Regex(""%%REGEX%%"");
            TextAsset textAsset = Resources.Load<TextAsset>(""Tables/%%FILE_NAME%%"");

            using StringReader stringReader = new StringReader(textAsset.text);
            stringReader.ReadLine();
            stringReader.ReadLine();

            while (true)
            {
                string line = stringReader.ReadLine();
                if (line == null)
                {
                    break;
                }

                string[] columns = regex.Split(line);
                for (int i = 0; i < columns.Length; i++)
                {
                    columns[i] = columns[i].Replace(""\"""", """");
                }

[[LOAD_ROW]]
            }

            Resources.UnloadAsset(textAsset);
        }

[[METHOD]]
    }
}
";

        public enum VariableType
        {
            Unknown = -1,

            Primitive,
            String,
            Color,
            Color32,
            Vector3,
            Vector2,
            Enum,
        }

        public struct Header
        {
            public string name;
            public string validatedName;
        }

        public struct DataType
        {
            public string name;
            public string primitiveName;
            public VariableType variableType;
            public bool isArray;

            public static DataType Parse(string field)
            {
                DataType dataType = new DataType();
                if (string.IsNullOrEmpty(field))
                {
                    dataType.variableType = VariableType.Unknown;
                    return dataType;
                }

                dataType.isArray = field.EndsWith("[]");

                string primitiveName = dataType.isArray ? field.Substring(0, field.Length - 2) : field;
                dataType.name = dataType.isArray ? $"IReadOnlyList<{primitiveName}>" : primitiveName;
                dataType.primitiveName = primitiveName;

                switch (primitiveName)
                {
                    case "bool":
                    case "byte":
                    case "sbyte":
                    case "char":
                    case "decimal":
                    case "double":
                    case "float":
                    case "int":
                    case "uint":
                    case "long":
                    case "ulong":
                    case "short":
                    case "ushort":
                        dataType.variableType = VariableType.Primitive;
                        break;

                    case "string":
                        dataType.variableType = VariableType.String;
                        break;

                    case "color":
                    case "Color":
                        dataType.variableType = VariableType.Color;
                        break;

                    case "color32":
                    case "Color32":
                        dataType.variableType = VariableType.Color32;
                        break;

                    case "vector3":
                    case "Vector3":
                        dataType.variableType = VariableType.Vector3;
                        break;

                    case "vector2":
                    case "Vector2":
                        dataType.variableType = VariableType.Vector2;
                        break;

                    default:
                        dataType.variableType = VariableType.Enum;
                        break;
                }

                return dataType;
            }
        }

        public class CSVData
        {
            public string FileName;
            public string ClassName;
            public Header[] Headers;
            public DataType[] Types;
            public bool UseDictionary;
            public int ColumnIdx;
        }

        private static readonly string path = Application.dataPath + "/Tables/";
        private static readonly string csvRegexPattern = ",(?=(?:[^\"]*\"[^\"]*\")*(?![^\"]*\"))";
        private static readonly Regex csvRegex = new Regex(csvRegexPattern);

        private static readonly Dictionary<string, Action<StringBuilder, CSVData>> addFuncs = new Dictionary<string, Action<StringBuilder, CSVData>>()
        {
            { "[[VARIABLE]]",               AddVariable },
            { "[[VARIABLE_INITIALIZER]]",   AddVariableInitializer },
            { "[[MEMBER_VARIABLE]]",        AddMemberVariable },
            { "[[LOAD_ROW]]",               AddLoadRow },
            { "[[METHOD]]",                 AddMethod },
        };

        [MenuItem("Assets/Create/C# Script from csv", false, 80)]
        public static void Generate()
        {
            if (Selection.objects == null || Selection.objects.Length == 0)
            {
                Debug.LogError($"[{nameof(CSVTableCodeGenerator)}] Select .csv file");
                return;
            }

            for (int i = 0; i < Selection.objects.Length; i++)
            {
                UnityEngine.Object obj = Selection.objects[i];

                string assetPath = AssetDatabase.GetAssetPath(obj);
                if (!assetPath.EndsWith(".csv"))
                {
                    Debug.LogError($"[{nameof(CSVTableCodeGenerator)}] Select .csv file\nFile : {obj.name}");
                    continue;
                }

                CSVData csvData = LoadCSV(assetPath);
                if (csvData == null)
                {
                    Debug.LogError($"[{nameof(CSVTableCodeGenerator)}] csv load failed\nFile : {obj.name}");
                    continue;
                }

                try
                {
                    string str = GenerateScriptFromCSV(csvData);
                    SaveAs(str, $"{path}{csvData.ClassName}.cs");
                }
                catch
                {
                    Debug.LogError($"[{nameof(CSVTableCodeGenerator)}] Generating codes failed\nFile : {obj.name}");
                }
            }
        }

        private static CSVData LoadCSV(string path)
        {
            CSVData csvData = new CSVData();
            CodeDomProvider codeDomProvider = CodeDomProvider.CreateProvider("C#");

            csvData.FileName = path.Split('/').Last().Replace(".csv", "");
            csvData.ClassName = ToPascalCase(csvData.FileName);

            StreamReader streamReader = new StreamReader(path);
            for (int lineIdx = 0, prevColumnCount = -1; ; lineIdx++)
            {
                string line = streamReader.ReadLine();
                if (line == null)
                {
                    break;
                }

                string[] columns = csvRegex.Split(line);
                if (prevColumnCount >= 0 && prevColumnCount != columns.Length)
                {
                    return null;
                }

                for (int i = 0; i < columns.Length; i++)
                {
                    columns[i] = columns[i].Replace("\"", "");
                }

                switch (lineIdx)
                {
                    case 0:
                        for (int i = 0; i < columns.Length; i++)
                        {
                            if (columns[i] != "@")
                            {
                                csvData.ColumnIdx = i;
                                break;
                            }
                        }

                        const string keySuffix = "_KEY";
                        if (columns[csvData.ColumnIdx].EndsWith(keySuffix))
                        {
                            columns[csvData.ColumnIdx] = columns[csvData.ColumnIdx].Remove(columns[csvData.ColumnIdx].Length - keySuffix.Length);
                            csvData.UseDictionary = true;
                        }

                        csvData.Headers = new Header[columns.Length];
                        for (int i = 0; i < csvData.Headers.Length; i++)
                        {
                            csvData.Headers[i] = new Header()
                            {
                                name = columns[i],
                                validatedName = codeDomProvider.IsValidIdentifier(columns[i]) ? columns[i] : $"@{columns[i]}",
                            };
                        }

                        break;

                    case 1:
                        DataType[] types = new DataType[columns.Length];
                        for (int i = 0; i < types.Length; i++)
                        {
                            types[i] = DataType.Parse(columns[i]);
                        }

                        csvData.Types = types;
                        break;
                }

                prevColumnCount = columns.Length;
            }

            return csvData;
        }

        private static string GenerateScriptFromCSV(CSVData csvData)
        {
            StringBuilder builder = new StringBuilder();

            string scripts = scriptTemplate.
                Replace("%%CLASS_NAME%%", csvData.ClassName).
                Replace("%%REGEX%%", csvRegexPattern.Replace("\"", "\\\"")).
                Replace("%%FILE_NAME%%", csvData.FileName);

            using StringReader reader = new StringReader(scripts);
            while (true)
            {
                string line = reader.ReadLine();
                if (line == null)
                {
                    break;
                }

                if (addFuncs.TryGetValue(line, out Action<StringBuilder, CSVData> del))
                {
                    del(builder, csvData);
                }
                else
                {
                    builder.AppendLine(line);
                }
            }

            return builder.ToString();
        }

        private static void AddVariable(StringBuilder builder, CSVData csvData)
        {
            string template = "            public %%TYPE%% %%NAME%% { get; private set; }";

            for (int i = csvData.ColumnIdx; i < csvData.Headers.Length; i++)
            {
                string line = template.
                    Replace("%%TYPE%%", csvData.Types[i].name).
                    Replace("%%NAME%%", csvData.Headers[i].validatedName);

                builder.AppendLine(line);
            }
        }

        private static void AddVariableInitializer(StringBuilder builder, CSVData csvData)
        {
            for (int i = csvData.ColumnIdx; i < csvData.Headers.Length; i++)
            {
                string template = $"                %%NAME%% = {GetParseTemplate(csvData.Types[i])};";
                string line = template.
                    Replace("%%NAME%%", csvData.Headers[i].validatedName).
                    Replace("%%FIELD%%", $"source[{i}]").
                    Replace("%%TYPE%%", csvData.Types[i].primitiveName);

                builder.AppendLine(line);
            }
        }

        private static void AddMemberVariable(StringBuilder builder, CSVData csvData)
        {
            string template = csvData.UseDictionary ?
@"        private Dictionary<%%TYPE%%, Row> rows = new Dictionary<%%TYPE%%, Row>();

        public IReadOnlyDictionary<%%TYPE%%, Row> Rows => rows;" :

@"        private List<Row> rows = new List<Row>();

        public IReadOnlyList<Row> Rows => rows;";

            string line = template.Replace("%%TYPE%%", csvData.Types[csvData.ColumnIdx].name);

            builder.AppendLine(line);
        }

        private static void AddLoadRow(StringBuilder builder, CSVData csvData)
        {
            string template = csvData.UseDictionary ?
                $"                rows.Add({GetParseTemplate(csvData.Types[csvData.ColumnIdx])}, new Row(columns));" :
                "                rows.Add(new Row(columns));";

            string line = template.
                    Replace("%%FIELD%%", $"columns[{csvData.ColumnIdx}]").
                    Replace("%%TYPE%%", csvData.Types[csvData.ColumnIdx].name);

            builder.AppendLine(line);
        }

        private static void AddMethod(StringBuilder builder, CSVData csvData)
        {
            string indexerTemplate =
@"        public Row this[%%TYPE%% key] => rows[key];";

            string getTemplate =
@"        public bool ContainsKey(%%TYPE%% key) => rows.ContainsKey(key);
        public bool TryGetValue(%%TYPE%% key, out Row row) => rows.TryGetValue(key, out row);";

            string findTemplate =
@"        public Row Find%%NAME%%(%%TYPE%% key)
        {
            return rows.Find((row) => %%EQUAL_OPERATOR%%);
        }";

            string findAllTemplate =
@"        public List<Row> Find%%NAME%%All(%%TYPE%% key)
        {
            return rows.FindAll((row) => %%EQUAL_OPERATOR%%);
        }";

            if (csvData.UseDictionary)
            {
                string indexerLine = indexerTemplate.Replace("%%TYPE%%", csvData.Types[csvData.ColumnIdx].name);
                builder.AppendLine(indexerLine);

                string getLine = getTemplate.
                    Replace("%%TYPE%%", csvData.Types[csvData.ColumnIdx].name);
                builder.AppendLine(getLine);
            }
            else
            {
                string indexerLine = indexerTemplate.Replace("%%TYPE%%", "int");
                builder.AppendLine(indexerLine);

                for (int i = csvData.ColumnIdx; i < csvData.Headers.Length; i++)
                {
                    string equalOperatorTemplate = GetEqualOperatorTemplate(csvData.Types[i]);
                    string equalLine = equalOperatorTemplate.
                        Replace("%%LHS%%", "row.%%VALID_NAME%%").
                        Replace("%%RHS%%", "key");

                    string fineLine = findTemplate.
                        Replace("%%EQUAL_OPERATOR%%", equalLine).
                        Replace("%%NAME%%", csvData.Headers[i].name).
                        Replace("%%VALID_NAME%%", csvData.Headers[i].validatedName).
                        Replace("%%TYPE%%", csvData.Types[i].name);
                    builder.AppendLine(fineLine);

                    string findAllLine = findAllTemplate.
                        Replace("%%EQUAL_OPERATOR%%", equalLine).
                        Replace("%%NAME%%", csvData.Headers[i].name).
                        Replace("%%VALID_NAME%%", csvData.Headers[i].validatedName).
                        Replace("%%TYPE%%", csvData.Types[i].name);
                    builder.AppendLine(findAllLine);
                }
            }
        }

        private static void SaveAs(string str, string path)
        {
            try
            {
                using StreamWriter writer = File.CreateText(path);
                writer.Write(str);

                Debug.Log($"[{nameof(CSVTableCodeGenerator)}] Script saved : {path}");
            }
            catch (Exception e)
            {
                Debug.LogError($"[{nameof(CSVTableCodeGenerator)}] {e}");
            }
            finally
            {
                AssetDatabase.Refresh();
            }
        }

        private static string GetParseTemplate(VariableType variableType) => variableType switch
        {
            VariableType.Primitive => "%%TYPE%%.Parse(%%FIELD%%)",
            VariableType.String => "%%FIELD%%",
            VariableType.Color => @"new Func<string, Color>((s) => { string[] values = Regex.Replace(s, ""\\s+"", """").Split(','); return new Color(float.Parse(values[0]), float.Parse(values[1]), float.Parse(values[2]), float.Parse(values[3])); }).Invoke(%%FIELD%%)",
            VariableType.Color32 => @"new Func<string, Color32>((s) => { string[] values = Regex.Replace(s, ""\\s+"", """").Split(','); return new Color32(byte.Parse(values[0]), byte.Parse(values[1]), byte.Parse(values[2]), byte.Parse(values[3])); }).Invoke(%%FIELD%%)",
            VariableType.Vector3 => @"new Func<string, Vector3>((s) => { string[] values = Regex.Replace(s, ""\\s+"", """").Split(','); return new Vector3(float.Parse(values[0]), float.Parse(values[1]), float.Parse(values[2])); }).Invoke(%%FIELD%%)",
            VariableType.Vector2 => @"new Func<string, Vector2>((s) => { string[] values = Regex.Replace(s, ""\\s+"", """").Split(','); return new Vector2(float.Parse(values[0]), float.Parse(values[1])); }).Invoke(%%FIELD%%)",
            VariableType.Enum => "(%%TYPE%%)Enum.Parse(typeof(%%TYPE%%), %%FIELD%%, false)",

            _ => throw new NotImplementedException(),
        };

        private static string GetParseTemplate(DataType dataType)
        {
            string template = GetParseTemplate(dataType.variableType);

            if (dataType.isArray)
            {
                template = template.Replace("%%FIELD%%", "s.Substring(1, s.Length - 2)");
                template = $@"Regex.Split(%%FIELD%%, ""(?<=\\])(?=\\[)"").Select((s) => {template}).ToArray()";
            }

            if (dataType.isArray || dataType.variableType != VariableType.String)
            {
                template = $"string.IsNullOrEmpty(%%FIELD%%) ? default({dataType.name}) : {template}";
            }

            return template;
        }

        private static string GetEqualOperatorTemplate(DataType dataType)
        {
            if (dataType.isArray)
            {
                return @"%%LHS%% == %%RHS%%";
            }

            return dataType.variableType switch
            {
                VariableType.Color32 => @"%%LHS%%.r == %%RHS%%.r && %%LHS%%.g == %%RHS%%.g && %%LHS%%.b == %%RHS%%.b && %%LHS%%.a == %%RHS%%.a",

                _ => @"%%LHS%% == %%RHS%%",
            };
        }

        private static string ToPascalCase(string original)
        {
            Regex invalidCharsRgx = new Regex("[^_a-zA-Z0-9]");
            Regex whiteSpace = new Regex(@"(?<=\s)");
            Regex startsWithLowerCaseChar = new Regex("^[a-z]");
            Regex firstCharFollowedByUpperCasesOnly = new Regex("(?<=[A-Z])[A-Z0-9]+$");
            Regex lowerCaseNextToNumber = new Regex("(?<=[0-9])[a-z]");
            Regex upperCaseInside = new Regex("(?<=[A-Z])[A-Z]+?((?=[A-Z][a-z])|(?=[0-9]))");

            // replace white spaces with undescore, then replace all invalid chars with empty string
            var pascalCase = invalidCharsRgx.Replace(whiteSpace.Replace(original, "_"), string.Empty)
                // split by underscores
                .Split(new char[] { '_' }, StringSplitOptions.RemoveEmptyEntries)
                // set first letter to uppercase
                .Select(w => startsWithLowerCaseChar.Replace(w, m => m.Value.ToUpper()))
                // replace second and all following upper case letters to lower if there is no next lower (ABC -> Abc)
                .Select(w => firstCharFollowedByUpperCasesOnly.Replace(w, m => m.Value.ToLower()))
                // set upper case the first lower case following a number (Ab9cd -> Ab9Cd)
                .Select(w => lowerCaseNextToNumber.Replace(w, m => m.Value.ToUpper()))
                // lower second and next upper case letters except the last if it follows by any lower (ABcDEf -> AbcDef)
                .Select(w => upperCaseInside.Replace(w, m => m.Value.ToLower()));

            return string.Concat(pascalCase);
        }
    }
}
